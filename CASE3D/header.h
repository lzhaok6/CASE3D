#pragma once
#include <vector>

struct LOBATTOstruct LOBATTO(int n);
struct LOCAL_NODEstruct LOCAL_NODE(int n);
//local node array is derived from "LNA_info" 
struct meshgenerationstruct meshgeneration();
//read the fem mesh file generated by Gmsh 
struct TD_LOCAL_NODEstruct TD_LOCAL_NODE(int n);
//the local node definition by MpCCI kernel 
//generate sem points from fem points by Lagrange interpolation  
struct TD_ELE_GENstruct TD_ELE_GEN(int NEL, int XNODE, int NNODE, int XNEL, int YNEL, double XL, double YL);
//used to generate mesh on wet surface (identical with the model file read by data.c)
struct GLLQUADstruct GLLQUAD(double* Z, double* WL, int n, int SEM);
struct LOCAL_SHAPEstruct LOCAL_SHAPE(int*** LNA, int n, int NQUAD);
struct LEGENDREstruct LEGENDRE(int Nq, int n);
struct LOCAL_GSHAPEstruct LOCAL_GSHAPE(double* S, int*** LNA, int NINT);
struct JACOBIANstruct JACOBIAN(int NEL, double **GCOORD, int **IEN, int*** LNA);
struct GLOBAL_SHAPEstruct GLOBAL_SHAPE(int NEL, double***SHL, double****XS, double**JACOB);
struct MATRIXstruct MATRIX(int NEL, int NNODE, double***SHL, double*W, int**IEN, int***LNA, double****XS, double****SHG, double**JACOB);
double EIGENMAX(double** QMASTER, double*** HMASTER, int NEL);
struct TIMINTstruct TIMINT(double LMAX);
struct NRBstruct NRB(int NNODE, double **GCOORD, int*** LNA);
double** WAVE_IN(int NNODE, double** GCOORD, double* T, int TIME, double** PIN, double DT, double PPEAK, double TAU, double XC, double YC, double ZC, double XO, double YO, double ZO);
void FSILINK(int*** LNA);
struct interface_mappingstruct interface_mapping(int fluid2structure, double ** GCOORD);
void TIME_INT(int NNODE, double** GCOORD, int***LNA_3D, int**IEN, int NEL, int TIME, double *T, double DT, int NDT,
	double*** HMASTER, double* Q, double KAPPA, double PPEAK, double TAU, double XC, double YC, double ZC,
	double XO, double YO, double ZO, double ***SHOD, double** gamman, double** gamma_tn, double****Gn, double****SHG);
//used to map the force value from user defined fluid mesh to MpCCI defined mesh and map the displacement in the opposite way. 

const int N = 1;    //N is the element order of fluid mesh 
const int NINT = N + 1; //NINT=N+1;
typedef struct owetsurf {
	double *WBS; //wet surface structure force derived from displacement sent back from Nastran 
	double *PSI; //integrated incident pressure 
	double *DI;  //displacement predictor 
	double **DISPI; //incident displacement
	double **DISP; //total (actual) displacement (the combination of incident displacement and dynamic displacement)
	double **DISP_norm; //normal displacement out of fluid domain for two concecutive time steps
	double *WP; //wet surface pressure, representing AP, CP, DP previously
	double *WPIN; //wet surface incident pressure, APIN, ...
	double*** FPMASTER;
	double*** FPMASTER_2D; 
	int **IEN_2D; //wet surface connectivity matrix (used to write MpCCI model file and information mapping. The wetted surface information from MpCCI is defined this way)
	int **IEN_algo2; //
	int **IEN_gb; //connectivity matrix on 2D surface pointing to global points.
	int FSNEL; 
	int *GIDF;   //Coupled fluid element array (numbering)
	int *GIDN_MpCCI; //wet nodes on coupling surfaces
	int GIDNct_MpCCI; //wet nodes number on coupling surfaces
	int *GIDN; 
	int GIDNct; 
	double** norm; //store the normal direction of linear elements 
	double** Jacob_2D; //the Jacobian value of 2D element on wetted surface
	double** Jacob_test; 
	int LNA_2D[NINT][NINT];
	int LNA_algo2[2][2]; //The local node orientation of the linear element in algorithm2
	int FP[NINT*NINT]; //The 1D version of DP in order to facilitate the calculation of FPMASTER
	int FP_2D[NINT*NINT];
	double** JACOB;
	int Jacob_face[2]; //Used to identify which coordinate dimension (x,y or z/xi,eta,zeta?) to be used for surface 2D Jacobian matrix calculation.  
	int LNA_norm[4];
	int** IEN_py; //the linear element connectivity matrix of 2D physical groups (boundaries) separated from the original 2D high-order elements
	double**** xs;
	double****xs_2D; //for the 2D elements on wetted surface
	double ***phi_fem;
	int LNA_JB2D[4]; 
	//LNA_JB2D is the node numbering of the wetted surface 2D element in the linear element numbering scheme. Used to derive the 2D Jacobian matrix. The numbering sequence set to be the same as LNA_norm which is the local numbering of the 2D element used to obtain the coordinate. 
	//LNA_norm is originally devised for mapping algorithm 2. However, it is leveraged in 2D Jacobian determinant derivation (assuming linear geometric mapping) because it numbering is the corner nodes of the 2D wetted surface element.  
	double****GSHL_2D;
	int dir; 
} OWETSURF;

//Store the properties on NRB surface (currently just one)
//Different from the wetted surface, the element on the NRB surface is high-order
typedef struct nrbsurf {
	double*** ADMASTER; //The boundary force integration weight for each element on NRB surface
	//double* ADMASTERG; //the lumped boundary force integration weight for each node on NRB surface
	double** JACOB; //3D Jacobian determinant with one additional quadrature point (Dedicated for boundary force integration on boundaries). 
	int** IEN_gb; //connectivity matrix on 2D surface pointing to global points. (From the physical group definition of the mesh file)
	int NEL_nrb; //the element number of the 2D element 
	//int NNODE_nrb; //The total number of node on NRBC
	int LNA_2D[NINT][NINT]; 
	int DP[NINT*NINT]; //The 1D version of DP in order to facilitate the calculation of ADMASTER
	int DP_2D[NINT*NINT];
	int* NRBA; 
	int NRBNODE;
	double**norm; 
	int LNA_norm[4];
	double**** xs;
	double **XEST_kn;
	double **XEST;
	double **XEST_ukn;
	double **XNRBORG2;
	double ***XNRB_kn;
	double ***XNRB_ukn;
	double ***XNRB;
	double **XCOR_ukn;
	double **XCOR;
	int* NRBELE_ARR; 
	int LNA_JB2D[4];
	double ***P_dev; //The gradient of the pressure of NRB element points [NEL_nr][NINT*NINT][3]
	double** Jacob_2D;
	double****GSHL_2D;
	double****xs_2D;
	int Jacob_face[2];
	double **angle_disp1;
	double **angle_disp2;
	double ***disp_mag;
	//double* ADMASTERG; 
	//double *BNRB; 
} NRBSURF; 

struct LOBATTOstruct {
	double* Z;
	double* WL;
};

struct LOCAL_NODEstruct {
	int*** LNA;
	int L[NINT*NINT*NINT][3];
};

struct TD_LOCAL_NODEstruct {
	int** LNA;
};
struct TD_ELE_GENstruct {
	double **GCOORD;
	int **IEN;
};

struct meshgenerationstruct {
	double **GCOORD;
	int **IEN;
	int NNODE;
	int NEL;
	//double** AYIN;
	//int wetnodenum;
	//int*wetnode;
	std::vector<std::vector<std::vector<int>>> BCIEN;
	int** IEN_wt; ////connecvitity matrix of wetted surface (after removing the free surface elements)
};

struct interface_mappingstruct {
	double energy_sent;
	double energy_rec;
};

struct GLLQUADstruct {
	double* S;   //ARRAY OF N+1 GLL QUADRATURE POINTS
	double* W;   //ARRAY OF N+1 GLL QUADRATURE WEGHTS
};

struct LEGENDREstruct {
	double** LN;
};

struct LOCAL_SHAPEstruct {
	double*** SHL;
	double ***SHOD;
};

struct LOCAL_GSHAPEstruct {
	double***** GSHL;
	//double****GSHL_2D; 
	double MCOORD[8][3];
};

struct JACOBIANstruct {
	double****XS;
	double**JACOB; 
};

struct GLOBAL_SHAPEstruct {
	double****SHG;
};

struct MATRIXstruct {
	double**QMASTER;
	double***HMASTER;
	double *Q;  //GLOBAL CAPACITANCE MATRIX
	double ****gamma;
	double **gamman;
	double **gamman2;
	double ****gamma_t;
	double **gamma_tn;
	double *****G;
	double ****Gn;
};

struct NRBstruct {
	double *ADMASTERG;
	int* NRBA_t;
	int NNODE_nrb;
};

struct TIMINTstruct {
	double DT; //TIME STEP
	int NDT;    //NUMBER OF TIME STEP 
	//int dtscale;
};

//Input values
//const double SX = 1.0;
const double SX = 8.5344 / 2; //14ft
const double SY = 1.2192; //4ft 
//const double SY = 0.141;
const double SZ = 4.8768; //16ft
//const double SZ = 1.0;
const int NC = 1;   //NC is the element order on coupling mesh 
const int NCINT = NC + 1; //NCINT=NC+1;
const int Nq = N + 1; //The integration order for boundary nodal force term (exact integration). Should be at least one unit higher than the interpolation order (for algorithm 1, 2 and 5) since the Gauss-Legendre-Lobatto nodes are not accuracy enough. Need not to be used for FEM case since the Gauss-Legendre nodes is accurate enough. 
const int NqINT = Nq + 1;
const int refine = 1; //The refinement rate of fluid mesh against base fluid mesh for h refinement. 
const int hpref = refine*N; //total refinement level of h and p refinement
//const int hprefg = refine*N; //The level of Gauss-Legendre integration on the base mesh (dedicated for mapping algorithm 5) this could integrate the nodal force on the linear base mesh upto the order 2(refine*N)-2
const int hprefg = 1;
const int mappingalgo = 2; //Mapping algoritm, please refer to the description in the main file (1, 2, 3, 4)
const double RHO = 1025.0; //original
//const double RHO = 989.0; //Bleich-Sandler
const int WAVE = 2; //1 for plane wave; 2 for spherical wave 
const int wavdirc[3] = { 0,1,0 }; //the direction of incident plane wave (positive y axis) 
const double C = 1500.0; //original  
//const double C = 1450.0; //Bleich_Sandler
const double CFLFRAC = 0.5;  //original 
const int dtscale = 1;
const double BETA = 0.25;   //original 
const double TTERM = 0.08;    //SIMULATION END TIME 
const int CAV = 1; //1 for cavitation, 0 for non-cavitation 
const double PSAT = 0.0; //saturated pressure 
const double pi = 3.141593;
const double grav = 9.81;
const double PATM = 101.3e3; //pa 
const double stdoff = 20; //ft
const double depth = 25; //ft
const double W = 60; //charge weight (lb)

//standoff point in spherical wave case 
//const double XO = 0; //the origin is at the deck center of the barge
//const double YO = -SY;
//const double ZO = SZ / 2;
//the parameter to control whether a tabulated smoothed waveform is used 
const double output_int = 5e-4; //output file time interval
const int debug = 1; //is the code in debug mode?
const int tfm = 0; //is total field model used? 
const int tensorfactorization = 0;
const int TNT = 1;
const int output = 0; 
const int FEM = 0; //Is this a first order FEM code? 
const int nodeforcemap2 = 1; //If the property to be mapped by MpCCI is nodal force (use 0 if the property is absolute pressure)
const int owsfnumber = 4; //For the FSP case, we defined 4 wetted surfaces. 
const int nrbsurfnumber = 4; //The number of NRB surface. 
//const int owsfnumber = 1; //For the FSP case, we defined 4 wetted surfaces. 
//const int nrbsurfnumber = 1; //The number of NRB surface. 
const int wt_pys_num[4] = { 0,1,2,3 };  //the physical group number that corresponds to the wet surface (physical group 3)
const int nrb_pys_num[4] = { 4,5,6,7 };
//const int wt_pys_num[1] = { 0 };
//const int nrb_pys_num[1] = { 1 };
const double XHE = 0.3048;
const double YHE = 0.3048;
const double DY = 2 * SY;
const int SYNEL = 4 * refine;
const double xo = SY; 
const int Bleich = 0; 
const int improvednrb = 1;