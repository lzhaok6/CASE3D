#pragma once
#include <vector>

//#define OMAXWETSURF 5   //maximum wet surface number 
struct LOBATTOstruct LOBATTO(int n);
struct LOCAL_NODEstruct LOCAL_NODE(int n);
//local node array is derived from "LNA_info" 
struct meshgenerationstruct meshgeneration();
//read the fem mesh file generated by Gmsh 
struct TD_LOCAL_NODEstruct TD_LOCAL_NODE(int n);
//the local node definition by MpCCI kernel 
//generate sem points from fem points by Lagrange interpolation  
struct TD_ELE_GENstruct TD_ELE_GEN(int NEL, int XNODE, int NNODE, int XNEL, int YNEL, double XL, double YL);
//used to generate mesh on wet surface (identical with the model file read by data.c)
struct GLLQUADstruct GLLQUAD(double* Z, double* WL, int n, int SEM);
struct LOCAL_SHAPEstruct LOCAL_SHAPE(int*** LNA, int n, int NQUAD);
struct LEGENDREstruct LEGENDRE(int N);
struct LOCAL_GSHAPEstruct LOCAL_GSHAPE(double* S, int*** LNA, int NINT);
struct JACOBIANstruct JACOBIAN(int NEL, double **GCOORD, int **IEN, int*** LNA);
struct GLOBAL_SHAPEstruct GLOBAL_SHAPE(int NEL, double***SHL, double****XS, double**JACOB);
struct MATRIXstruct MATRIX(int NEL, int NNODE, double***SHL, double*W, int**IEN, int***LNA, double****XS, double****SHG, double**JACOB);
double EIGENMAX(double** QMASTER, double*** HMASTER, int NEL);
struct TIMINTstruct TIMINT(double LMAX);
void NRB(int NNODE, double **GCOORD, double* W, int*** LNA, int**IEN, int NEL, double***SHL, double***SHOD);
double** WAVE_IN(int NNODE, double** GCOORD, double* T, int TIME, double** PIN, double DT, double PPEAK, double TAU, double XC, double YC, double ZC, double XO, double YO, double ZO);
void FSILINK(double* W, int*** LNA, int**IEN, double***SHL, double**GCOORD, int NNODE, double***SHOD);
struct interface_mappingstruct interface_mapping(int fluid2structure, int**IEN_3D, int***LNA_3D, int**LNA_2D, int**LNA_base, int**LNA_basealgo5, double *Z, int TIME, double** GCOORD, double ***phi_fem, double *W);
void TIME_INT(int NNODE, double** GCOORD, double* W, int**LNA_2D, int***LNA_3D, int**IEN, int NEL, double* S, double***SHL, int TIME, double *T, double DT, int NDT, double* Z,
	double** AYIN, double*** HMASTER, double* Q, double*** phi_fem, double KAPPA, double PPEAK, double TAU, double XC, double YC, double ZC,
	double XO, double YO, double ZO, double ***SHOD, double ****gamma, double****gamma_t, double*****G, double** gamman, double** gamma_tn, double****Gn);
//used to map the force value from user defined fluid mesh to MpCCI defined mesh and map the displacement in the opposite way. 


const int N = 1;    //N is the element order of fluid mesh 
const int NINT = N + 1; //NINT=N+1;

typedef struct owetsurf {
	//double **SF; //weighted integration factor: the previous AF, CF, DF... 
	int *GIDF;   //Coupled fluid element array (numbering)
	//double NORM; //if the inward normal direction of a surface is identical with the axis, NROM=1, vice versa (used to get dynamic displacement on wet surfaces)
	//double NORM_BF; //the direction of fluid force to structure (If the force is positive x then NORM_BF=1.0, vice versa)
	double *WBS; //wet surface structure force derived from displacement sent back from Nastran 
	double *PSI; //integrated incident pressure 
	double *DI;  //displacement predictor 
	double **DISPI; //incident displacement
	double **DISP; //total (actual) displacement (the combination of incident displacement and dynamic displacement)
	double **DISP_norm; //normal displacement out of fluid domain for two concecutive time steps
	//double**BF1;    //For mapping algorithm1, 3 and 4
	//double*BF2;     //For mapping algorithm2
	//double**BF3;    //For mapping algorithm3
	//double** BP;    //For mapping algorithm4
	//double** BPG;   //For mapping algorithm5 
	double *WP; //wet surface pressure, representing AP, CP, DP previously
	double *WPIN; //wet surface incident pressure, APIN, ...
	//int *FP; //2D node count in one 3D element on wet surfaces. (Does not exist in non_MpCCI code)
	double*** FPMASTER;
	double*** FPMASTER_2D; 
	//int *SP; //2D node count in one 3D element on NRB  
	int **IEN_2D; //wet surface connectivity matrix (used to write MpCCI model file and information mapping. The wetted surface information from MpCCI is defined this way)
	int **IEN_algo2; //
	int **IEN_gb; //connectivity matrix on 2D surface pointing to global points.
	//int dir; //the direction of displacement and force on a specific wet surface (0 means x direction; 1 means y and 2 means z)
	//double location; //the constant coordinate component of wet surface points. (used to calculate displacement from node coordinate)  
	//double OBF_val; //The total force on wet surface before interface_mapping (used to check if the interface force mapping is conservative)
	//double **XYHE_gb; 
	//int FSNEL_fem; //element number on SEM made FEM coupling surface 
	int FSNEL; 
	int *GIDN; //wet nodes on coupling surfaces
	int GIDNct; //wet nodes number on coupling surfaces
	//int GIDNct_st; //wet nodes number on coupling surfaces (structure)
	//int**IEN_base;
	//double**NW; //Node weight on base fluid mesh for displacement mapping(algorithm 3 and 4)
	//int **eletran; //connectivity matrix of coarse and fine mesh
	//int XNEL;
	//int YNEL;
	int* DP; //2D local node numbering of NRB elements (the surface sequence is different from the structural wet surface). 
	//double* nodecoord_mpcci;
	double** norm; //store the normal direction of linear elements 
	double** Jacob_2D; //the Jacobian value of 2D element on wetted surface
	int LNA_2D[NINT][NINT];
	int LNA_algo2[2][2]; //The local node orientation of the linear element in algorithm2
	int FP[NINT*NINT]; //The 1D version of DP in order to facilitate the calculation of FPMASTER
	double** JACOB;
	//int* GIDN;
	//int GIDNct; 
} OWETSURF;

//Store the properties on NRB surface (currently just one)
//Different from the wetted surface, the element on the NRB surface is high-order
typedef struct nrbsurf {
	double*** ADMASTER; //The boundary force integration weight for each element on NRB surface
	double* ADMASTERG; //the lumped boundary force integration weight for each node on NRB surface
	double** JACOB; //3D Jacobian determinant with one additional quadrature point (Dedicated for boundary force integration on boundaries). 
	int** IEN_gb; //connectivity matrix on 2D surface pointing to global points. (From the physical group definition of the mesh file)
	int NEL_nrb; //the element number of the 2D element 
	int NNODE_nrb; //The total number of node on NRBC
	int LNA_2D[NINT][NINT]; 
	int DP[NINT*NINT]; //The 1D version of DP in order to facilitate the calculation of ADMASTER
	//std::vector<int>NRBA; 
	int* NRBA; 
	int NRBNODE;
} NRBSURF; 

struct LOBATTOstruct {
	double* Z;
	double* WL;
};

struct LOCAL_NODEstruct {
	int*** LNA;
	int L[NINT*NINT*NINT][3];
};

struct TD_LOCAL_NODEstruct {
	int** LNA;
};
struct TD_ELE_GENstruct {
	double **GCOORD;
	int **IEN;
};

struct meshgenerationstruct {
	double **GCOORD;
	int **IEN;
	int NNODE;
	int NEL;
	double** AYIN;
	//int wetnodenum;
	//int*wetnode;
	std::vector<std::vector<std::vector<int>>> BCIEN;
	int** IEN_wt; ////connecvitity matrix of wetted surface (after removing the free surface elements)
};

struct interface_mappingstruct {
	double energy_sent;
	double energy_rec;
};

struct GLLQUADstruct {
	double* S;   //ARRAY OF N+1 GLL QUADRATURE POINTS
	double* W;   //ARRAY OF N+1 GLL QUADRATURE WEGHTS
};

struct LEGENDREstruct {
	double** LN;
};

struct LOCAL_SHAPEstruct {
	double*** SHL;
	double ***SHOD;
};

struct LOCAL_GSHAPEstruct {
	double***** GSHL;
	double****GSHL_2D; 
};

struct JACOBIANstruct {
	double****XS;
	double****XS_2D; //for the 2D elements on wetted surface
	double**JACOB; 
};

struct GLOBAL_SHAPEstruct {
	double****SHG;
};

struct MATRIXstruct {
	double**QMASTER;
	double***HMASTER;
	double *Q;  //GLOBAL CAPACITANCE MATRIX
	double ****gamma;
	double **gamman;
	double **gamman2;
	double ****gamma_t;
	double **gamma_tn;
	double *****G;
	double ****Gn;
};

struct NRBstruct {
	double **AD;
	double *ADMASTERG;
	int *NRBA;
	int **nloc; //local node numbering on NRB surfaces (sequentially)
	int NRBNODE;
	int* NRBNODE_loc;
	//double **ADMASTER;
	int NRBELE;
	int **NRBELE_ARR;
	int *nrbele;
};

struct TIMINTstruct {
	double DT; //TIME STEP
	int NDT;    //NUMBER OF TIME STEP 
	//int dtscale;
};

//Input values
//const int N = 2;    //N is the element order of fluid mesh 
//const int NINT = N + 1; //NINT=N+1;
const int NC = 1;   //NC is the element order on coupling mesh 
const int NCINT = NC + 1; //NCINT=NC+1;
const int Nq = N + 1; //The integration order for boundary nodal force term (exact integration). Should be at least one unit higher than the interpolation order (for algorithm 1, 2 and 5) since the Gauss-Legendre-Lobatto nodes are not accuracy enough. Need not to be used for FEM case since the Gauss-Legendre nodes is accurate enough. 
const int NqINT = Nq + 1;
const int refine = 1; //The refinement rate of fluid mesh against base fluid mesh for h refinement. 
const int hpref = refine*N; //total refinement level of h and p refinement
//const int hprefg = refine*N; //The level of Gauss-Legendre integration on the base mesh (dedicated for mapping algorithm 5) this could integrate the nodal force on the linear base mesh upto the order 2(refine*N)-2
const int hprefg = 1;
const int mappingalgo = 2; //Mapping algoritm, please refer to the description in the main file (1, 2, 3, 4)
const double RHO = 1025.0; //original
//const double RHO = 989.0; //Bleich-Sandler
const int WAVE = 2; //1 for plane wave; 2 for spherical wave 
const int wavdirc[3] = { 0,1,0 }; //the direction of incident plane wave (positive y axis) 
const double C = 1500.0; //original 
//const double C = 1450.0; //Bleich-Sandler 
//const double PPEAK = 15.11e6;    //25 depth, 20 stdoff (3ft draft)
//const double PPEAK = 15.50e6; //25 depth, 20 stdoff (4ft draft)
//const double PPEAK = 0.712e6; //(Bleich-Sandler)
//const double PPEAK = 19.827e6; //15 depth, 20 stdoff (3ft draft)
//const double TAU = 0.3255e-3; //25 depth, 20 stdoff (3ft draft)
//const double TAU = 0.32376e-3;  //25 depth, 20 stdoff (4ft draft)
//const double TAU = 0.999e-3; //0.712Mpa (Bleich-Sandler)
//const double TAU = 0.308e-3; //15 depth, 20 stdoff (3ft draft)
//const double XC = 0.0;  //symmetrical in X direction
//const double YC = -7.62;  //25ft depth 
//const double YC = -4.572;  //15ft depth 
//const double ZC = 8.5344; //6.096 + 2.4384  (20ft stdoff) 
const double CFLFRAC = 0.5;  //original 
const int dtscale = 1;
const double BETA = 0.25;   //original 
const double TTERM = 0.08;    //SIMULATION END TIME 
const int CAV = 1; //1 for cavitation, 0 for non-cavitation 
const double PSAT = 0.0; //saturated pressure 
const double pi = 3.141593;
const double grav = 9.81;
const double PATM = 101.3e3; //pa 
const double stdoff = 10; //ft
const double depth = 30; //ft
const double W = 60; //charge weight (lb)

					 
//Mesh definition
//Abaqus2 symmetric
/*
const double SX = 8.5344 / 2;
//const double SY = 0.9144 + 0.2032;
const double SY = 0.9144;
const double SZ = 4.8768;
const int SXNEL = 42;
const int SYNEL = 9;
const int SZNEL = 48;
const double AX = 1.4224;
const double DY = 2 * SY;
const double BZ = 1.2192;
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
*/

//Abaqus2 symmetric with waterline adjusted (0.1m)
/*
const double SX = 4.2672; //8.5344/2
const double SY = 0.9144 + 0.2032;
const double SZ = 4.8768;
const int SXNEL = 42;
const int SYNEL = 11;
const int SZNEL = 48;
const double AX = 1.4224;
const double DY = 2 * SY;
const double BZ = 1.2192;
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
*/

/*
//Abaqus 10 symmetric (0.3048m/1ft mesh) with waterline adjusted (0.3048)
const double SX = 8.5344 / 2; //14ft
//const double SY = (0.9144 + 0.3048) * 2; //8ft
const double SY = (0.9144 + 0.3048); //4ft
//const double SY = 0.3048; //1ft
const double SZ = 4.8768; //16ft
const int SXNEL = 14 * refine;
const int SYNEL = 4 * refine; //for 4 ft draft
//const int SYNEL = 8 * refine; //for 8 ft draft
//const int SYNEL = refine;
const int SZNEL = 16 * refine;	
const double AX = 1.524; //5ft
const double DY = 2 * SY; //8ft
//const double DY = SY;
const double BZ = 1.2192; //4ft
//const double BZ = 1.2192 * 6; //24ft
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
const double DRAFT = SY;
*/

//Abaqus 10 symmetric extended (0.3048m/1ft mesh) with waterline adjusted (0.3048)
/*
//the XHE and ZHE are slightly changed to make the base fluid mesh mismatch with base structural mesh
const double SX = 8.5344 / 2; //14ft
//const double SY = (0.9144 + 0.3048) * 2; //8ft
const double SY = (0.9144 + 0.3048); //4ft
//const double SY = 0.3048; //1ft
const double SZ = 4.8768; //16ft
const int SXNEL = 12 * refine;
const int SYNEL = 4 * refine; //for 4 ft draft
//const int SYNEL = 8 * refine; //for 8 ft draft
//const int SYNEL = refine;
const int SZNEL = 12 * refine;
const double AX = SX / 2; //5ft
const double DY = 2 * SY; //8ft
//const double DY = SY;
const double BZ = SZ/4; //4ft
//const double BZ = 1.2192 * 6; //24ft
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
*/

/*
//Abaqus 10 symmetric extended2 (0.1524m/0.5ft mesh) with waterline adjusted (0.3048)
const double SX = 8.5344 / 2; //14ft
//const double SY = (0.9144 + 0.3048) * 2; //8ft
const double SY = (0.9144 + 0.3048); //4ft
//const double SY = 0.3048; //1ft
const double SZ = 4.8768; //16ft
const int SXNEL = 28 * refine;
const int SYNEL = 8 * refine; //for 4 ft draft
//const int SYNEL = 8 * refine; //for 8 ft draft
//const int SYNEL = refine;
const int SZNEL = 32 * refine;
const double AX = 1.524; //5ft
const double DY = 2 * SY; //8ft
//const double DY = SY;
const double BZ = 1.2192; //4ft
//const double BZ = 1.2192 * 6; //24ft
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
const double DRAFT = SY;
*/

//Abaqus 10 symmetric extended3 enlarge the fluid domain (BZ=10ft)
const double SX = 8.5344 / 2; //14ft
//const double SY = (0.9144 + 0.3048) * 2; //8ft
const double SY = (0.9144 + 0.3048); //4ft
//const double SY = 0.3048; //1ft
const double SZ = 4.8768; //16ft
const int SXNEL = 14 * refine;
const int SYNEL = 4 * refine; //for 4 ft draft
//const int SYNEL = 8 * refine; //for 8 ft draft
//const int SYNEL = refine;
const int SZNEL = 16 * refine;
const double AX = 1.524; //5ft
//const double AX = 1.8288; //6ft
const double DY = 2 * SY; //8ft
//const double DY = SY;
const double BZ = 3.048; //10ft
//const double BZ = 1.2192 * 6; //24ft
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
const double DRAFT = SY;


//Abaqus 11 symmetric (0.1524m/0.5ft mesh) with waterline adjusted (0.3048)
/*
const double SX = 8.5344 / 2; //14ft
const double SY = 0.9144 + 0.3048; //4ft
const double SZ = 4.8768; //16ft
const int SXNEL = 28 * refine;
const int SYNEL = 8 * refine;
const int SZNEL = 32 * refine;
const double AX = 1.524; //5ft
const double DY = 5 * SY; //20ft
const double BZ = 1.2192; //4ft
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
const double DRAFT = SY;
*/

//Abaqus 12 symmetric (0.25ft mesh) with waterline adjusted (0.3048)
/*
const double SX = 8.5344 / 2; //14ft
const double SY = 0.9144 + 0.3048; //4ft
const double SZ = 4.8768; //16ft
const int SXNEL = 56 * refine;
const int SYNEL = 16 * refine;
const int SZNEL = 64 * refine;
const double AX = 1.524; //5ft
const double DY = 2 * SY; //8ft
const double BZ = 1.2192; //4ft
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
*/

//smaller shell model with 0.2032m draft
/*
const double SX = 4.2672; //8.5344/2
const double SY = 0.2032;
const double SZ = 4.8768;
const int SXNEL = 42 * refine;
const int SYNEL = 2 * refine;
const int SZNEL = 48 * refine;
const double AX = 1.4224;
const double DY = 2 * (0.9144 + 0.2032);
const double BZ = 1.2192;
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
*/

//coarser mesh for debug purposes
/*
const double SX = 4.2672; //8.5344/2
const double SY = 0.2032;
const double SZ = 4.8768;
const int SXNEL = 21 * refine;
const int SYNEL = 1 * refine; //original
const int SZNEL = 24 * refine;
const double AX = 1.4224;
const double DY = 2 * 0.2032;
const double BZ = 1.2192;
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
*/

//0.1m base fluid mesh
//Further decrease the size of the shell structure with 0.2032m draft
/*
const double SX = 4.2672 / 6; //8.5344/2
const double SY = 0.2032;
const double SZ = 4.8768 / 6;
const int SXNEL = 7 * refine;
const int SYNEL = 2 * refine;
const int SZNEL = 8 * refine;
//const double AX = 1.4224;
const double AX = 0.0;
//const double DY = 2 * (0.9144 + 0.2032);
const double DY = 5 * (0.9144 + 0.2032);
//const double BZ = 1.2192;
const double BZ = 0.0;
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
const double DRAFT = SY; 
*/

//0.05m base fluid mesh
//Further decrease the size of the shell structure with 0.2032m draft
/*
const double SX = 4.2672 / 6; //8.5344/2
const double SY = 0.2032;
const double SZ = 4.8768 / 6;
const int SXNEL = 14 * refine;
const int SYNEL = 4 * refine;
const int SZNEL = 16 * refine;
//const double AX = 1.4224;
const double AX = 0.0;
const double DY = 2 * (0.9144 + 0.2032);
//const double BZ = 1.2192;
const double BZ = 0.0;
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
*/

//0.025m base fluid mesh
//Further decrease the size of the shell structure with 0.2032m draft
/*
const double SX = 4.2672 / 6; //8.5344/2
const double SY = 0.2032;
const double SZ = 4.8768 / 6;
const int SXNEL = 28 * refine;
const int SYNEL = 8 * refine;
const int SZNEL = 32 * refine;
//const double AX = 1.4224;
const double AX = 0.0;
const double DY = 2 * (0.9144 + 0.2032);
//const double BZ = 1.2192;
const double BZ = 0.0;
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
*/

//3D Bleich-Sandler case configuration (unit surface)

/*
const double SX = 1; //8.5344/2
//const double SY = 0.141; //draft of the plate
const double SY = 0.141;
const double SZ = 1;
const int SXNEL = 10 * refine;
//const int SYNEL = 2 * refine;
const int SYNEL = 2 * refine;
const int SZNEL = 10 * refine;
//const double AX = 1.4224;
const double AX = 0.0;
//const double DY = 2 * (0.9144 + 0.2032);
const double DY = 3.8070;
//const double BZ = 1.2192;
const double BZ = 0.0;
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
*/

//smaller Bleich-Sandler mesh
//3D Bleich-Sandler case configuration
/*
const double SX = 0.1; //8.5344/2
const double SY = 0.141;
const double SZ = 0.1;
const int SXNEL = 1 * refine;
//const int SYNEL = 2 * refine;
const int SYNEL = 2 * refine;
const int SZNEL = 1 * refine;
//const double AX = 1.4224;
const double AX = 0.0;
//const double DY = 2 * (0.9144 + 0.2032);
const double DY = 3.8070;
//const double BZ = 1.2192;
const double BZ = 0.0;
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
const double DRAFT = SY;
*/

//smaller Bleich-Sandler mesh (extended to make the base mesh mismatch)
//3D Bleich-Sandler case configuration
/*
const double SX = 0.1; //8.5344/2
const double SY = 0.141;
const double SZ = 0.1;
const int SXNEL = 3* refine;
//const int SYNEL = 2 * refine;
const int SYNEL = 2 * refine;
const int SZNEL = 3* refine;
//const double AX = 1.4224;
const double AX = 0.0;
//const double DY = 2 * (0.9144 + 0.2032);
const double DY = 3.8070;
//const double BZ = 1.2192;
const double BZ = 0.0;
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
const double DRAFT = 0.141; 
*/

//the mesh for reproducing the result in Klenow CH6 
/*
const double SX = 0.15; //8.5344/2
const double SY = 0.15;
const double SZ = 0.1;
const int SXNEL = 1 * refine;
const int SYNEL = 1 * refine;
const int SZNEL = 1 * refine;
//const double AX = 1.4224;
const double AX = 0.0;
//const double DY = 2 * (0.9144 + 0.2032);
const double DY = 3.0;
//const double BZ = 1.2192;
const double BZ = 0.0;
const double XHE = SX / SXNEL;
const double YHE = SY / SYNEL;
const double ZHE = SZ / SZNEL;
const double DRAFT = 5.08; 
*/

//standoff point in plane wave case
//const double xo = AY; //stand-off distance in plane wave case (always positive) 
const double xo = SY;
//standoff point in spherical wave case 
//const double XO = 0; //the origin is at the deck center of the barge
//const double YO = -SY;
//const double ZO = SZ / 2;
//the parameter to control whether a tabulated smoothed waveform is used 
const int Abaquswaveform = 0; //==1 means Abaqus smoothed wave form is used, 0 otherwise 
const int internalmesh = 0;  //==1 means the mesh is generated within the code. Otherwise, an external mesh generated by Gmsh would be imported
const int internalLNA = 0;
const double output_int = 5e-4; //output file time interval
const int debug = 1; //is the code in debug mode?
const int Bleich = 0; //is this a Bleich-Sandler case?
const int tfm = 1; //is total field model used? 
const int tensorfactorization = 0;
const int TNT = 1;
const int output = 0; 
const int FEM = 0; //Is this a first order FEM code? 
const int nodeforcemap2 = 1; //If the property to be mapped by MpCCI is nodal force (use 0 if the property is absolute pressure)
const int owsfnumber = 1; //For the FSP case, we defined 4 wetted surfaces. 
const int nrbsurfnumber = 1; //The number of NRB surface. 
